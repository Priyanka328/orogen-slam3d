name "slam3d"

using_library 'velodyne_lidar'
using_library 'slam3d'
using_library 'transformer'
using_library 'envire'

import_types_from 'base'
import_types_from 'velodyne_lidar/MultilevelLaserScan.h'
import_types_from 'slam3d/include/GICPConfiguration.hpp'
import_types_from 'envire'
import_types_from 'tasks/rock-types.hpp'

using_task_library 'telemetry_provider'


## Mapper using Pointclouds
task_context "PointcloudMapper" do
	needs_configuration
	
	input_port 'scan', '/base/samples/Pointcloud'
	output_port 'cloud', '/base/samples/Pointcloud'
	output_port 'map2robot', 'base/samples/RigidBodyState'
	output_port 'map2odometry', 'base/samples/RigidBodyState'
	port_driven 'scan'
	
	transformer do
		transform "robot", "odometry"
		align_port 'scan'
		max_latency 0.5
	end
	
	operation('generate_map')
	.returns('/bool')
	.doc("Generates and sends the environment map.")
	 
	operation('optimize')
	.returns('/bool')
	.doc("Starts the global optimization using the current SLAM backend.")
	
	property('scan_resolution', '/double')
	.doc("Pointclouds are downsampled to this resolution before being added to the map.")
	 
	property('map_resolution', '/double')
	.doc("Map-Pointcloud is downsampled to this resolution before being published.")
	
	property('neighbor_radius', '/double')
	.doc("Distance to search for neighbors when adding additional constraints to the graph.")
	
	property('map_outlier_radius', '/double')
	.doc("Map-Pointcloud outlier rejection radius.")
	
	property('map_outlier_neighbors', '/unsigned')
	.doc("Map-Pointcloud outlier rejection minimum neighbors within radius.")
	
	property('min_translation', '/double')
	.doc("Minimum distance between two subsequent nodes.")
	
	property('min_rotation', '/double')
	.doc("Minimum rotation difference between two subsequent nodes.")
	 
	property('use_odometry', '/bool')
	.doc("Whether to use odometry port.")
	
	property('add_odometry_edges', '/bool')
	.doc("Whether to add odometry edges to the graph.")
	
	property('odometry_time_tolerance', '/double')
	.doc("Tolerance of odometry samples in milliseconds.")

	property('gicp_config', '/slam/GICPConfiguration')
	.doc("Parameters for Generalized ICP.")
	
	property('log_level', '/int')
	.doc("Debug(0), Info(1), Warn(2), Error(3), Fatal(4)")
	
	property('robot_name', '/std/string')
	.doc("This robot's name.")

	property('map_frame', '/std/string')
	.doc("The frame that the map is represented in.")
end

## Distributed Mapper using Pointclouds
task_context "DistributedPointcloudMapper" do
	subclasses "PointcloudMapper"
	
	input_port 'external_in', '/slam3d/LocalizedPointcloud'
	output_port 'external_out', '/slam3d/LocalizedPointcloud'
	
	periodic 1.0
end

## Task to dump velodyne-Scans to KITTI-Format
task_context "PointcloudToBinary" do
	input_port 'pcl', '/base/samples/Pointcloud'
	input_port 'odometry', '/base/samples/RigidBodyState'
	periodic 0.1
end

## Filter to reduce velodyne-scans taking indoor
task_context "PointcloudFilter" do
	input_port 'cloud_in', '/base/samples/Pointcloud'
	output_port 'cloud_out', '/base/samples/Pointcloud'
	port_driven 'cloud_in'
	
	property('min_height', '/double')
	.doc("Remove all points below this height.")
	
	property('max_height', '/double')
	.doc("Remove all points above this height.")
	
	property('min_distance', '/double')
	.doc("Remove all points within this radius of the sensor.")

	property('max_distance', '/double')
	.doc("Remove all points beyond this radius of the sensor.")
end

## Convert MultilevelLaserScan to Pointcloud
task_context "ScanConverter" do
	input_port 'scan', '/velodyne_lidar/MultilevelLaserScan'
	output_port 'cloud', '/base/samples/Pointcloud'
	port_driven 'scan'
end

## Task to create Multi-Layer-Surface-map
task_context "MLSMapProjector" do
	input_port 'cloud', '/base/samples/Pointcloud'
	output_port 'envire_map', ro_ptr('std/vector</envire/BinaryEvent>')
	port_driven 'cloud'
	
	property('size_x', '/double')
	.doc("Map size in x-direction (meter).")
	 
	property('size_y', '/double')
	.doc("Map size in y-direction (meter).")
	
	property('offset_x', '/double')
	.doc("Position of grid origin in x-direction (meter).")
	 
	property('offset_y', '/double')
	.doc("Position  of grid origin in y-direction (meter).")
	
	property('min_z', '/double')
	.doc("Minimum z-value for grid cells (meter).")
	
	property('max_z', 'double')
	.doc("Maximum z-value for grid cells (meter).")
	
	property('resolution', '/double')
	 .doc("Resolution (size of grid-cell) of the map (meter).")
end

task_context "Multiplexer" do
	subclasses "telemetry_provider::Multiplexer"
end

task_context "Demultiplexer" do
	subclasses "telemetry_provider::Demultiplexer"
end
