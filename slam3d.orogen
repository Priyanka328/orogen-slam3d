name "slam3d"

using_library 'velodyne_lidar'
using_library 'slam3d'
using_library 'transformer'
using_library 'envire'
using_library 'octomap'

import_types_from 'base'
import_types_from 'velodyne_lidar/MultilevelLaserScan.h'
import_types_from 'slam3d/GICPConfiguration.hpp'
import_types_from 'envire'
import_types_from 'envire/maps/MLSConfiguration.hpp'
import_types_from 'OctoMapConfiguration.hpp'

## Mapper using Pointclouds
task_context "PointcloudMapper" do
	needs_configuration

	input_port 'scan', '/base/samples/Pointcloud'
	output_port 'cloud', '/base/samples/Pointcloud'
	output_port 'envire_map', ro_ptr('std/vector</envire/BinaryEvent>')
	output_port 'map2robot', 'base/samples/RigidBodyState'
	output_port 'map2odometry', 'base/samples/RigidBodyState'

	periodic 0.1

	transformer do
		transform "robot", "odometry"
		align_port 'scan'
		max_latency 0.5

		transform "laser", "robot"

		transform_output "map2robot", "robot" => "map"
		transform_output "map2odometry", "odometry" => "map"
	end

	operation('generate_cloud')
	.returns('/bool')
	.doc("Generates and sends the accumulated pointcloud.")

	operation('generate_map')
	.returns('/bool')
	.doc("Generates the envire map.")

	operation('optimize')
	.returns('/bool')
	.doc("Starts the global optimization using the current SLAM backend.")

	operation('write_graph')
	.returns('/bool')
	.doc("Writes internal graph structure to file.")

	property('scan_resolution', '/double', 0.01)
	.doc("Pointclouds are downsampled to this resolution before being added to the map.")

	property('map_resolution', '/double', 0.01)
	.doc("Map-Pointcloud is downsampled to this resolution before being published.")

	property('optimization_rate', '/int', 0)
	.doc("Optimize the graph every X scans, that are added to the map.")

	property('map_publish_rate', '/int', 0)
	.doc("Publish Map-Pointcloud every X scans, that are added to the map.")

	property('neighbor_radius', '/double', 1.0)
	.doc("Distance to search for neighbors when adding additional constraints to the graph.")

	property('max_neighbor_links', '/int', 5)
	.doc("Maximum number of additional constraints per node added to the graph.")

	property('patch_building_range', '/int', 0)
	.doc("Number of steps to follow BFS when building local patches for matching.")

	property('map_outlier_radius', '/double', 0.2)
	.doc("Map-Pointcloud outlier rejection radius.")

	property('map_outlier_neighbors', '/unsigned', 2)
	.doc("Map-Pointcloud outlier rejection minimum neighbors within radius.")

	property('min_translation', '/double', 0.1)
	.doc("Minimum distance between two subsequent nodes.")

	property('min_rotation', '/double', 0.25)
	.doc("Minimum rotation difference between two subsequent nodes.")

	property('use_odometry', '/bool', true)
	.doc("Whether to use odometry port.")

	property('add_odometry_edges', '/bool', true)
	.doc("Whether to add odometry edges to the graph.")

	property('gicp_config', '/slam3d/GICPConfiguration')
	.doc("Parameters for Generalized ICP.")

	property('gicp_coarse_config', '/slam3d/GICPConfiguration')
	.doc("Parameters for coarse Generalized ICP when doing loop closures.")
	
	property('log_type', '/int', 0)
	.doc("Standard(0), Base(1), File(2)")
	
	property('log_level', '/int', 2)
	.dynamic()
	.doc("Debug(0), Info(1), Warn(2), Error(3), Fatal(4)")

	property('robot_name', '/std/string', "robot")
	.doc("This robot's name.")

	property('map_frame', '/std/string', "map")
	.doc("The frame that the map is represented in.")

	property('use_colors_as_viewpoints', '/bool', false)
	.doc("Whether to get viewpoints from pointcloud's color vector.")

	property('grid_size_x', '/double', 10)
	.doc("Map size in x-direction (meter).")

	property('grid_size_y', '/double', 10)
	.doc("Map size in y-direction (meter).")

	property('grid_offset_x', '/double', -5)
	.doc("Position of grid origin in x-direction (meter).")

	property('grid_offset_y', '/double', -5)
	.doc("Position  of grid origin in y-direction (meter).")

	property('grid_min_z', '/double', -3)
	.doc("Minimum z-value for grid cells (meter).")

	property('grid_max_z', 'double', 3)
	.doc("Maximum z-value for grid cells (meter).")

	property('grid_resolution', '/double', 0.05)
	.doc("Resolution (size of grid-cell) of the map (meter).")
	
	property('grid_mls_config', '/envire/MLSConfiguration')
	.doc("Multi-Layer-Surface-Map specific configuration.")
end

## Mapper that creates a Multi-Level-Surface-Map from an OcTree
task_context "OcTreeMapper" do
	subclasses "PointcloudMapper"
	
	operation('remove_dynamic_objects')
	.returns('/bool')
	.doc("Removes points from scans that have changed in the environment.")
	
	property('octo_map_config', 'slam3d/OctoMapConfiguration')
	.doc("OctoMap specific configuration.")
end

## Pointcloud-Mapper for 2D
task_context "PointcloudMapper2D" do
	subclasses "PointcloudMapper"
end

## Task to dump velodyne-Scans to KITTI-Format
task_context "PointcloudToBinary" do
	input_port 'pcl', '/base/samples/Pointcloud'
	input_port 'odometry', '/base/samples/RigidBodyState'
	periodic 0.1
end

## Filter to reduce velodyne-scans taking indoor
task_context "PointcloudFilter" do
	input_port 'cloud_in', '/base/samples/Pointcloud'
	output_port 'cloud_out', '/base/samples/Pointcloud'
	port_driven 'cloud_in'

	property('min_height', '/double', -1)
	.doc("Remove all points below this height.")

	property('max_height', '/double', 1)
	.doc("Remove all points above this height.")

	property('min_distance', '/double', 0.5)
	.doc("Remove all points within this radius of the sensor.")

	property('max_distance', '/double', 10)
	.doc("Remove all points beyond this radius of the sensor.")
	
	property('pass_rate', '/int', 1)
	.doc("Only pass every n'th scan.")
end

## Convert MultilevelLaserScan (deprecated format)
## or a Depthmap from a velodyne scanner to Pointcloud format
task_context "ScanConverter" do
	error_states :MULTIPLE_INPUT_CONNECTIONS

	input_port 'scan', '/velodyne_lidar/MultilevelLaserScan'
        input_port 'depth_map', '/base/samples/DepthMap'
	output_port 'cloud', '/base/samples/Pointcloud'
	port_driven
end

## Convert LaserScan to Pointcloud
task_context "LineScanConverter" do
	input_port 'scan', '/base/samples/LaserScan'
	output_port 'cloud', '/base/samples/Pointcloud'
	port_driven 'scan'
end
