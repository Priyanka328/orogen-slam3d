name "slam3d"

using_library 'velodyne_lidar'
using_library 'slam3d'
using_library 'transformer'
using_library 'envire'
using_library 'octomap'

import_types_from 'base'
import_types_from 'velodyne_lidar/MultilevelLaserScan.h'
import_types_from 'slam3d/GICPConfiguration.hpp'
import_types_from 'envire'
import_types_from 'envire/maps/MLSConfiguration.hpp'
import_types_from 'OctoMapConfiguration.hpp'
import_types_from 'GridConfiguration.hpp'

## Mapper using Pointclouds
task_context "PointcloudMapper" do
	needs_configuration

	input_port 'scan', '/base/samples/Pointcloud'
	output_port 'cloud', '/base/samples/Pointcloud'
	output_port 'envire_map', ro_ptr('std/vector</envire/BinaryEvent>')
	output_port 'robot2map', 'base/samples/RigidBodyState'
	output_port 'odometry2map', 'base/samples/RigidBodyState'

	periodic 0.1

	transformer do
		transform "laser", "robot"
		transform "robot", "odometry"
		max_latency 0.5

		transform_output "robot2map", "robot" => "map"
		transform_output "odometry2map", "odometry" => "map"
	end

	operation('generate_cloud')
	.returns('/bool')
	.doc("Generates and sends the accumulated pointcloud.")

	operation('generate_map')
	.returns('/bool')
	.doc("Generates the envire map.")

	operation('optimize')
	.returns('/bool')
	.doc("Starts the global optimization using the current SLAM backend.")

	operation('force_add')
	.returns('/bool')
	.doc("Force to add one scan to the graph regardless of change in pose.")

	operation('write_graph')
	.returns('/bool')
	.doc("Writes internal graph structure to file.")

	operation('write_envire')
	.returns('/bool')
	.doc("Writes the serialized envire object to 'envire_path'.")

	operation('write_ply')
	.argument('folder_path', '/std/string')
	.returns('/bool')
	.doc("Writes the accumulated pointcloud as ply to the given folder.")

	property('scan_resolution', '/double', 0.01)
	.doc("Pointclouds are downsampled to this resolution before being added to the map.")

	property('map_resolution', '/double', 0.01)
	.doc("Map-Pointcloud is downsampled to this resolution before being published.")

	property('optimization_rate', '/int', 0)
	.doc("Optimize the graph every X scans, that are added to the map.")

	property('map_publish_rate', '/int', 0)
	.doc("Publish Map-Pointcloud every X scans, that are added to the map.")

	property('neighbor_radius', '/double', 1.0)
	.doc("Distance to search for neighbors when adding additional constraints to the graph.")

	property('max_neighbor_links', '/int', 5)
	.doc("Maximum number of additional constraints per node added to the graph.")

	property('patch_building_range', '/int', 0)
	.doc("Number of steps to follow BFS when building local patches for matching.")

	property('map_outlier_radius', '/double', 0.2)
	.doc("Map-Pointcloud outlier rejection radius.")

	property('map_outlier_neighbors', '/unsigned', 2)
	.doc("Map-Pointcloud outlier rejection minimum neighbors within radius.")

	property('min_translation', '/double', 0.1)
	.doc("Minimum distance between two subsequent nodes.")

	property('min_rotation', '/double', 0.25)
	.doc("Minimum rotation difference between two subsequent nodes.")

	property('use_odometry', '/bool', true)
	.doc("Whether to use odometry port.")

	property('add_odometry_edges', '/bool', true)
	.doc("Whether to add odometry edges to the graph.")

	property('start_pose', '/base/Pose')
	.doc("Start pose of the robot in map coordinates.")

	property('use_odometry_heading', '/bool', false)
	.doc("Whether to initialize the robot's pose from odometry.")

	property('gicp_config', '/slam3d/GICPConfiguration')
	.doc("Parameters for Generalized ICP.")

	property('gicp_coarse_config', '/slam3d/GICPConfiguration')
	.doc("Parameters for coarse Generalized ICP when doing loop closures.")

	property('log_type', '/int', 0)
	.doc("Standard(0), Base(1), File(2)")
	
	property('log_level', '/int', 2)
	.dynamic()
	.doc("Debug(0), Info(1), Warn(2), Error(3), Fatal(4)")

	property('robot_name', '/std/string', "robot")
	.doc("This robot's name.")

	property('map_frame', '/std/string', "map")
	.doc("The frame that the map is represented in.")

	property('use_colors_as_viewpoints', '/bool', false)
	.doc("Whether to get viewpoints from pointcloud's color vector.")

	property('grid_config', 'slam3d/GridConfiguration')
	.doc("Size and resolution of generated grid map.")

	property('grid_mls_config', '/envire/MLSConfiguration')
	.doc("Multi-Layer-Surface-Map specific configuration.")

	property('envire_path', '/std/string', "slam3d_envire")
	.doc("The path where to write the serialized envire map.")

	# The pointcloud will be added as first element to the graph
	property('apriori_ply_map', '/std/string')
end

## Mapper that creates a Multi-Level-Surface-Map from an OcTree
task_context "OcTreeMapper" do
	subclasses "PointcloudMapper"
	
	operation('remove_dynamic_objects')
	.returns('/bool')
	.doc("Removes points from scans that have changed in the environment.")
	
	property('octo_map_config', 'slam3d/OctoMapConfiguration')
	.doc("OctoMap specific configuration.")
end

## Pointcloud-Mapper for 2D
task_context "PointcloudMapper2D" do
	subclasses "PointcloudMapper"
end

## Task to dump velodyne-Scans to KITTI-Format
task_context "PointcloudToBinary" do
	input_port 'pcl', '/base/samples/Pointcloud'
	input_port 'odometry', '/base/samples/RigidBodyState'
	periodic 0.1
end

## Filter for pointclouds 
task_context "PointcloudFilter" do
	input_port 'input', '/base/samples/Pointcloud'
	output_port 'output', '/base/samples/Pointcloud'
	port_driven 'input'

	property('min_height', '/double', -1)
	.doc("Remove all points below this height.")

	property('max_height', '/double', 1)
	.doc("Remove all points above this height.")

	property('min_distance', '/double', 0.5)
	.doc("Remove all points within this radius of the sensor.")

	property('max_distance', '/double', 10)
	.doc("Remove all points beyond this radius of the sensor.")
	
	property('pass_rate', '/int', 1)
	.doc("Only pass every n'th scan.")
end

## Filter to remove outliers and moving objects
task_context "OcTreeFilter" do
	input_port 'input', '/base/samples/Pointcloud'
	output_port 'output', '/base/samples/Pointcloud'
	port_driven 'input'

	transformer do
		transform "laser", "odometry"
		align_port 'input'
		max_latency 0.5
	end

	property('log_type', '/int', 0)
	.doc("Standard(0), Base(1), File(2)")

	property('log_level', '/int', 2)
	.dynamic()
	.doc("Debug(0), Info(1), Warn(2), Error(3), Fatal(4)")

	property('min_height', '/double', -1)
	.doc("Remove all points below this height.")

	property('max_height', '/double', 1)
	.doc("Remove all points above this height.")

	property('min_distance', '/double', 0.5)
	.doc("Remove all points within this radius of the sensor.")

	property('max_distance', '/double', 10)
	.doc("Remove all points beyond this radius of the sensor.")
	
	property('pass_rate', '/int', 1)
	.doc("Only pass every n'th scan.")

	property('octo_map_config', 'slam3d/OctoMapConfiguration')
	.doc("OctoMap specific configuration.")
end

## Convert MultilevelLaserScan (deprecated format)
## or a Depthmap from a velodyne scanner to Pointcloud format
task_context "ScanConverter" do
	error_states :MULTIPLE_INPUT_CONNECTIONS

	input_port 'scan', '/velodyne_lidar/MultilevelLaserScan'
        input_port 'depth_map', '/base/samples/DepthMap'
	output_port 'cloud', '/base/samples/Pointcloud'
	port_driven
end

## Convert LaserScan to Pointcloud
task_context "LineScanConverter" do
	input_port 'scan', '/base/samples/LaserScan'
	output_port 'cloud', '/base/samples/Pointcloud'
	port_driven 'scan'
end

## Task to create Multi-Layer-Surface-Map
task_context "MLSMapProjector" do
	input_port 'cloud', '/base/samples/Pointcloud'
	output_port 'envire_map', ro_ptr('std/vector</envire/BinaryEvent>')
	port_driven 'cloud'

	property('grid_config', 'slam3d/GridConfiguration')
	.doc("Size and resolution of generated map.")

	property('mls_config', '/envire/MLSConfiguration')
	.doc("Multi-Layer-Surface-Map specific configuration.")
end
